Index: include/v8.h
===================================================================
--- include/v8.h	(revision 16317)
+++ include/v8.h	(working copy)
@@ -2492,6 +2492,11 @@
   size_t ByteLength() const;
 
   /**
+   * Base address of an array.
+   */
+  void *BaseAddress();
+
+  /**
    * Create a new ArrayBuffer. Allocate |byte_length| bytes.
    * Allocated memory will be owned by a created ArrayBuffer and
    * will be deallocated when it is garbage-collected,
Index: src/api.cc
===================================================================
--- src/api.cc	(revision 16317)
+++ src/api.cc	(working copy)
@@ -6423,6 +6423,14 @@
 }
 
 
+void* v8::ArrayBuffer::BaseAddress() {
+  i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();
+  if (IsDeadCheck(isolate, "v8::ArrayBuffer::ByteLength()")) return 0;
+  i::Handle<i::JSArrayBuffer> obj = Utils::OpenHandle(this);
+  return obj->backing_store();
+}
+
+
 Local<ArrayBuffer> v8::ArrayBuffer::New(size_t byte_length) {
   i::Isolate* isolate = i::Isolate::Current();
   EnsureInitializedForIsolate(isolate, "v8::ArrayBuffer::New(size_t)");
Index: test/cctest/test-api.cc
===================================================================
--- test/cctest/test-api.cc	(revision 16317)
+++ test/cctest/test-api.cc	(working copy)
@@ -2689,6 +2689,7 @@
   Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(1024);
   CheckInternalFieldsAreZero(ab);
   CHECK_EQ(1024, static_cast<int>(ab->ByteLength()));
+  CHECK_NE(0, ab->BaseAddress());
   CHECK(!ab->IsExternal());
   HEAP->CollectAllGarbage(i::Heap::kNoGCFlags);
 
@@ -2698,6 +2699,7 @@
   CHECK_EQ(1024, static_cast<int>(ab_contents.ByteLength()));
   uint8_t* data = static_cast<uint8_t*>(ab_contents.Data());
   ASSERT(data != NULL);
+  CHECK_EQ(data, ab->BaseAddress());
   env->Global()->Set(v8_str("ab"), ab);
 
   v8::Handle<v8::Value> result = CompileRun("ab.byteLength");
